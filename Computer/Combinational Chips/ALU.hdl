// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/02/ALU.hdl

/**
 * The ALU. Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&y, x|y on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * The bit-combinations that yield each function are 
 * documented in the book. In addition, the ALU 
 * computes two 1-bit outputs: if the ALU output
 * is 0, zr is set to 1; otherwise zr is set to 0;
 * If out<0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU manipulates the x and y
// inputs and then operates on the resulting values, 
// as follows:
// if (zx==1) set x = 0        // 16-bit constant
// if (nx==1) set x = ~x       // bitwise "not"
// if (zy==1) set y = 0        // 16-bit constant
// if (ny==1) set y = ~y       // bitwise "not"
// if (f==1)  set out = x + y  // integer 2's complement addition
// if (f==0)  set out = x & y  // bitwise "and"
// if (no==1) set out = ~out   // bitwise "not"
// if (out==0) set zr = 1
// if (out<0) set ng = 1

CHIP ALU {
 IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute  out = x + y (if 1) or out = x & y (if 0)
        no; // negate the out output?

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out==0), 0 otherwise
        ng; // 1 if (out<0),  0 otherwise

    PARTS:

    Mux16(a=x , b[0..15]=false , sel=zx , out=zxFunction );
    Not16(in=zxFunction , out=NOTzxFunction);
    Mux16(a=zxFunction , b=NOTzxFunction , sel=nx , out=nxFunction );


    //same for y
    Mux16(a=y , b[0..15]=false , sel=zy , out=zyFunction );
    Not16(in=zyFunction , out=NOTzyFunction);
    Mux16(a=zyFunction , b=NOTzyFunction , sel=ny , out=nyFunction );


    Add16(a =nxFunction , b = nyFunction , out =xADDy );
    And16(a =nxFunction , b = nyFunction , out =xANDy );

    Mux16(a=xANDy , b=xADDy , sel= f, out=fFunction );

    
    Not16(in=fFunction,out= NOTfFunction);

    //Output of the ALU
    Mux16(a=fFunction , b=NOTfFunction , sel=no , out=noFunction );
    
/*The following implementation are some workaround functions to implement the zr and ng pins because of the inefficiency of the language used as it is educational

//The real world implementation wouldn't be this for sure, and it would be using Or16Way with Not gate to generate the result of the zr and for ng it would be a junction from the msb wire and this is possible in the real world as it is a normal bus I can control.

//Conventional Code (Real World)
Mux16(a=fFunction , b=NOTfFunction , sel=no , out=out );
Or16Way(in=out, out=zr);
//Identity law
And(out[0], b=true, out = ng);
*/
//Language inefficiency Code



    
    Mux16(a=fFunction , b=NOTfFunction , sel=no , out[0..7]=Out1 );
    Mux16(a=fFunction , b=NOTfFunction , sel=no , out[8..15]=Out2 );

    //Print
    Mux16(a=fFunction , b=NOTfFunction , sel=no , out=out );

    ///Selecting msb from bus (MSB is the signed bit)
    Mux16(a=fFunction , b=NOTfFunction , sel=no , out[15..15]=msb );

    Or8Way(in=Out1, out=zr1 );
    Or8Way(in=Out2 , out=zr2 );
    Or(a=zr1 , b=zr2 , out=zrx );
    
    And(a=msb , b=true , out=ng );


    Not(in=zrx , out=zr );
    
 
    }